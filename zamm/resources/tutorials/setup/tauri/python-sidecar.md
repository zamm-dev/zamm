# Adding a Python sidecar

To add a Python sidecar to an existing Tauri project, first follow the steps for [setting up a new Python project](/zamm/resources/tutorials/setup/new-python-project.md), but skip the Git repo init part because we're already using Git.

Start the Python project as a subfolder inside the current directory, with the same name as the current project. For example, if the current project name is `Hello World`, you should have now created a `hello-world` folder inside the current directory. Rename it to `src-python` in keeping with the existing Tauri naming scheme, so that it's clear this is the Python component of our Hello World project.

```bash
$ mv hello-world src-python
```

Then install `pyinstaller`. If you get an error like this:

```bash
$ poetry add pyinstaller --group dev
Using version ^5.13.0 for pyinstaller

Updating dependencies
Resolving dependencies... (0.3s)

The current project's Python requirement (>=3.11,<4.0) is not compatible with some of the required packages Python requirement:
  - pyinstaller requires Python <3.13,>=3.7, so it will not be satisfied for Python >=3.13,<4.0

Because no versions of pyinstaller match >5.13.0,<6.0.0
 and pyinstaller (5.13.0) requires Python <3.13,>=3.7, pyinstaller is forbidden.
So, because zamm depends on pyinstaller (^5.13.0), version solving failed.

  • Check your dependencies Python requirement: The Python requirement can be specified via the `python` or `markers` properties
    
    For pyinstaller, a possible solution would be to set the `python` property to ">=3.11,<3.13"

    https://python-poetry.org/docs/dependency-specification/#python-restricted-dependencies,
    https://python-poetry.org/docs/dependency-specification/#using-environment-markers
```

then edit `src-python/pyproject.toml` first to specify specific versions of Python that this project is compatible with, as opposed to all future versions of Python by default. For example, if it looks like this:

```toml
...

[tool.poetry.dependencies]
python = "^3.11"

...
```

you should change it to

```toml
...

[tool.poetry.dependencies]
python = "~3.11"

...
```

Now, you should be able to execute this again successfully:

```bash
$ poetry add pyinstaller --group dev
Using version ^5.13.0 for pyinstaller

Updating dependencies
Resolving dependencies... Downloading https://files.pythonhosted.org/packages/d9/2f/675f01ccfccabf18cfb211feb7280cc13cfc1253eda4a6ffee32b56e1bdb/pyinstaller_hoo
Resolving dependencies... Downloading https://files.pythonhosted.org/packages/55/26/d0ad8b448476d0a1e8d3ea5622dc77b916db84c6aa3cb1e1c0965af948fc/pefile-2023.2.7
Resolving dependencies... (2.7s)

Package operations: 3 installs, 0 updates, 0 removals

  • Installing altgraph (0.17.3)
  • Installing pyinstaller-hooks-contrib (2023.6)
  • Installing pyinstaller (5.13.0)

Writing lock file
```

Now, assuming you don't already have an entry-point for the program, create one at `zamm/main.py`:


```python
"""Entry-point for ZAMM Python functionality."""

def hello_world():
    """Say hello-world."""
    print("Hi there world")

hello_world()
```

As noted in the Tauri docs:

> A binary with the same name and a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance, `"externalBin": ["binaries/my-sidecar"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux.

First find out the target triple:

```bash
$ rustc -Vv | grep host | cut -f2 -d' '
x86_64-unknown-linux-gnu
```

Then create the directory to store the generated binary in:

```bash
$ mkdir src-tauri/binaries
```

Edit `src-tauri/.gitignore` to include this new binaries directory, from:

```
# Generated by Cargo
# will have compiled files and executables
/target/


```

to

```
# Generated by Cargo
# will have compiled files and executables
/target/
/binaries/

```

Edit `src-tauri/.rustfmt.toml` to set a max line width that's the same as `black` in Python:

```toml
# to be compatible with Python black
max_width = 88
```

Now, bundle everything into one single file with the given name in that directory:

```bash
$ cd src-python
$ pyinstaller -F zamm/main.py --distpath ../src-tauri/binaries/ --name zamm-python-x86_64-unknown-linux-gnu
268 INFO: PyInstaller: 5.13.0
269 INFO: Python: 3.11.4
271 INFO: Platform: Linux-5.15.0-78-generic-x86_64-with-glibc2.31
...
28503 INFO: Copying bootloader EXE to /home/amos/Documents/ui/zamm/src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu
28504 INFO: Appending PKG archive to custom ELF section in EXE
28573 INFO: Building EXE from EXE-00.toc completed successfully.
```

If instead you get the error

```
...
  File "/root/.cache/pypoetry/virtualenvs/zamm-yQ9XAN83-py3.11/lib/python3.11/site-packages/PyInstaller/depend/bindepend.py", line 1018, in get_python_library_path
    raise IOError(msg)
OSError: Python library not found: libpython3.11.so, libpython3.11mu.so.1.0, libpython3.11.so.1.0, libpython3.11m.so, libpython3.11m.so.1.0
    This means your Python installation does not come with proper shared library files.
    This usually happens due to missing development package, or unsuitable build parameters of the Python installation.

    * On Debian/Ubuntu, you need to install Python development packages:
      * apt-get install python3-dev
      * apt-get install python-dev
    * If you are building Python by yourself, rebuild with `--enable-shared` (or, `--enable-framework` on macOS).
```

then follow the suggestions and install `python3-dev`.

We can edit the `src-python/Makefile` to produce this as a target, from this:

```Makefile
...
clean:
# https://stackoverflow.com/a/41386937/257583
	find . -type f -name '*.py[co]' -delete -o -type d -name __pycache__ -delete
```

to this:

```Makefile
...
clean:
# https://stackoverflow.com/a/41386937/257583
	find . -type f -name '*.py[co]' -delete -o -type d -name __pycache__ -delete
	rm -rf build

dist/main: $(shell find zamm -type f \( -name "*.py" \))
	poetry install
	poetry run pyinstaller -F zamm/main.py
	cp dist/main ../src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu
```

In doing this, you'll want to create `src-tauri/binaries/.gitignore` as such:

```
*
!.gitignore
```

and remove the binaries directory from `src-tauri/.gitignore`, from:

```
# Generated by Cargo
# will have compiled files and executables
/target/
/binaries/
```

to

```
# Generated by Cargo
# will have compiled files and executables
/target/
```

You may also want to move `dist/main` to the top, and then also edit the main `Makefile` of the project to make sure that it runs:

```
python-sidecar:
	cd src-python && poetry run make dist/main
```

If there's already a build command -- for example, `build-dev` -- you'll want to edit it from:

```
build-dev:
	cargo tauri build
```

to

```
build-dev: python-sidecar
	cargo tauri build
```

Check that the bundled app runs successfully:

```bash
$ src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu
Hello, World! You have been greeted from Python
$ src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu Amos
Hello, Amos! You have been greeted from Python
```

Finally, follow the instructions [here](https://tauri.app/v1/guides/building/sidecar/) to invoke that new binary from Tauri. First, edit `src-tauri/tauri.conf.json`. If it currently looks like this:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

then edit it to look like this:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "externalBin": [
        "binaries/zamm-python"
      ],
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

## Invoking the sidecar from Rust

We'll be following the instructions [here](https://tauri.app/v1/guides/building/sidecar/).

Edit `src-tauri/Cargo.toml` to enable the `process-command-api` feature:

```toml
...

[dependencies]
tauri = { version = "1.4", features = ["shell-open"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

...
```

to

```toml
...

[dependencies]
tauri = { version = "1.4", features = ["shell-open", "process-command-api"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

...
```

Add `futures` to allow us to synchronously get 

```rust
cargo add futures
    Updating crates.io index
      Adding futures v0.3.28 to dependencies.
             Features:
             + alloc
             + async-await
             + executor
             + std
             - bilock
             - cfg-target-has-atomic
             - compat
             - futures-executor
             - io-compat
             - thread-pool
             - unstable
             - write-all-vectored
    Updating crates.io index
```

Edit `src-tauri/src/main.rs`:

```rust
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

and modify the existing function to call this sidecar instead:

```rust
use tauri::api::process::{Command, CommandEvent};
use futures::executor;

// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
#[tauri::command]
fn greet(name: &str) -> String {
    // `new_sidecar()` expects just the filename, NOT the whole path like in JavaScript
    let (mut rx, mut _child) = Command::new_sidecar("zamm-python")
        .expect("failed to create `zamm-python` binary command")
        .args(vec![name])
        .spawn()
        .expect("Failed to spawn sidecar");

    // https://stackoverflow.com/a/52521592
    let result = executor::block_on(tauri::async_runtime::spawn(async move {
        let mut last_line = "No output".to_string();
        // read events such as stdout
        while let Some(event) = rx.recv().await {
            if let CommandEvent::Stdout(line) = event {
                last_line = format!("{} via Rust!", line);
            }
        }
        return last_line;
    }));
    return result.unwrap_or("Failed to get output".to_string());
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

We use `executor::block_on` here to turn the asynchronous call into a synchronous one. Make sure to

```bash
$ cargo add futures
```

if it's not yet installed.

Now if you run `yarn tauri dev`, you should be able to enter in your name and see it say:

> Hello, Amos! You have been greeted from Python via Rust!

### Testing

Your unit test from before:

```rust
#[cfg(test)]
mod tests {
    use super::greet;

    #[test]
    fn test_greet_name() {
        let result = greet("Test");
        assert_eq!(result, "Hello, Test! You have been greeted from Python via Rust!");
    }
}
```

may fail now with the message:

```rust
failures:

---- tests::test_greet_name stdout ----
thread 'tests::test_greet_name' panicked at 'asfd: Io(Os { code: 2, kind: NotFound, message: "No such file or directory" })', src/main.rs:27:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::test_greet_name

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--bin zamm`
```

If that is the case, you may want to

```bash
$ cargo add tauri_utils
```

so that you can copy this code from `Command::new_sidecar`:

```rust
use tauri_utils::platform;

fn relative_command_path(command: String) -> crate::Result<String> {
  match platform::current_exe()?.parent() {
    #[cfg(windows)]
    Some(exe_dir) => Ok(format!("{}\\{command}.exe", exe_dir.display())),
    #[cfg(not(windows))]
    Some(exe_dir) => Ok(format!("{}/{command}", exe_dir.display())),
    None => Err(crate::api::Error::Command("Could not evaluate executable dir".to_string()).into()),
  }
}
```

Except, of course, you're copying this inside your own code, so you can do:

```rust
fn relative_command_path(command: String) -> tauri::Result<String> {
    match platform::current_exe()?.parent() {
      #[cfg(windows)]
      Some(exe_dir) => Ok(format!("{}\\{command}.exe", exe_dir.display())),
      #[cfg(not(windows))]
      Some(exe_dir) => Ok(format!("{}/{command}", exe_dir.display())),
      None => Err(tauri::api::Error::Command("Could not evaluate executable dir".to_string()).into()),
    }
  }
```

and then in the function:

```rust
#[tauri::command]
fn greet(name: &str) -> String {
    let expected_binary_path = relative_command_path("zamm-python".to_string()).expect("Failed to get expected binary path");
    let (mut rx, mut _child) = Command::new_sidecar("zamm-python")
        .expect("failed to create `zamm-python` binary command")
        .args(vec![name])
        .spawn()
        .unwrap_or_else(|err| panic!("Failed to spawn sidecar at {}: {}", expected_binary_path, err));
    ...
```

This way, when it fails, you can at least get a more understandable error:

> thread 'tests::test_greet_name' panicked at 'Failed to spawn sidecar at /root/zamm/src-tauri/target/debug/deps/zamm-python: No such file or directory (os error 2)', src/main.rs:39:31

Now that you know this is the reason, you can at least copy it before testing:

```bash
$ cp ../src-python/dist/main target/debug/deps/zamm-python
```

Errors now should be actual errors:

```
failures:

---- tests::test_greet_name stdout ----
thread 'tests::test_greet_name' panicked at 'assertion failed: `(left == right)`
  left: `"Hello, Test! You have been greeted from Python via Rust"`,
 right: `"Hello, Test! You've been greeted from Rust!"`', src/main.rs:75:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::test_greet_name
```

Alternatively, to keep it as a unit-test rather than an integration test, you can mock the sidecar call as shown [here](/zamm/resources/tutorials/libraries/mockall.md)

## Invoking the sidecar from JS

If instead you'd like to call it directly from the frontend, edit `src/lib/Greet.svelte`. If it currently looks like this:

```svelte
<script lang="ts">
  import { invoke } from "@tauri-apps/api/tauri"

  let name = "";
  let greetMsg = ""

  async function greet(){
    // Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
    greetMsg = await invoke("greet", { name })
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={greet}>
    <input id="greet-input" placeholder="Enter a name..." bind:value={name} />
    <button type="submit">Greet</button>
  </form>
  <p>{greetMsg}</p>
</div>
```

then edit it to instead be:

```svelte
<script lang="ts">
  import { Command } from '@tauri-apps/api/shell'

  let name = "";
  let greetMsg = ""

  async function greet(){
    // alternatively, use `window.__TAURI__.shell.Command`
    // `binaries/my-sidecar` is the EXACT value specified on `tauri.conf.json > tauri > bundle > externalBin`
    const command = Command.sidecar('binaries/zamm-python', [
      name,
    ])
    const result = await command.execute()
    greetMsg = result.stdout + " via JavaScript!"
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={greet}>
    <input id="greet-input" placeholder="Enter a name..." bind:value={name} />
    <button type="submit">Greet</button>
  </form>
  <p>{greetMsg}</p>
</div>
```

For JS specifically, you will also need to edit `src-tauri/tauri.conf.json` to include the binary in the allowlist. In other words:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

should become

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true,
        "sidecar": true,
        "scope": [
          {
            "name": "binaries/zamm-python",
            "sidecar": true,
            "args": true
          }
        ]
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "externalBin": [
        "binaries/zamm-python"
      ],
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

Now if you run `yarn tauri dev`, you should be able to enter in your name and see:

> Hello, Amos! You have been greeted from Python via JavaScript!

Note that if you invoke it from the frontend, the binary will be located at `src-tauri/target/release/zamm-python`. Be sure to upload that binary too if you're running an end-to-end test on a CI environment.

### Testing

Follow the instructinos at [`vitest.md`](/zamm/resources/tutorials/setup/tauri/vitest.md).

## VS Code integration

After adding a Python sidecar, we should also recommend the Python extension in VS Code. Edit `.vscode/extensions.json` from

```json
{
  "recommendations": [
    "svelte.svelte-vscode",
    "tauri-apps.tauri-vscode",
    "rust-lang.rust-analyzer"
  ]
}
```

to

```json
{
  "recommendations": [
    "svelte.svelte-vscode",
    "tauri-apps.tauri-vscode",
    "rust-lang.rust-analyzer",
    "ms-python.python"
  ]
}
```

The value to put inside `recommendations` is the extension's ID.

## Miscellaneous

The final AppImage binary built by `cargo tauri build` will be approximately 12 MB bigger.
