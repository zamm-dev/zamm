# Adding a Python sidecar

To add a Python sidecar to an existing Tauri project, first follow the steps for [setting up a new Python project](/zamm/resources/tutorials/setup/new-python-project.md), but skip the Git repo init part because we're already using Git.

Start the Python project as a subfolder inside the current directory, with the same name as the current project. For example, if the current project name is `Hello World`, you should have now created a `hello-world` folder inside the current directory. Rename it to `src-python` in keeping with the existing Tauri naming scheme, so that it's clear this is the Python component of our Hello World project.

```bash
$ mv hello-world src-python
```

Then install `pyinstaller`. If you get an error like this:

```bash
$ poetry add pyinstaller --group dev
Using version ^5.13.0 for pyinstaller

Updating dependencies
Resolving dependencies... (0.3s)

The current project's Python requirement (>=3.11,<4.0) is not compatible with some of the required packages Python requirement:
  - pyinstaller requires Python <3.13,>=3.7, so it will not be satisfied for Python >=3.13,<4.0

Because no versions of pyinstaller match >5.13.0,<6.0.0
 and pyinstaller (5.13.0) requires Python <3.13,>=3.7, pyinstaller is forbidden.
So, because zamm depends on pyinstaller (^5.13.0), version solving failed.

  • Check your dependencies Python requirement: The Python requirement can be specified via the `python` or `markers` properties
    
    For pyinstaller, a possible solution would be to set the `python` property to ">=3.11,<3.13"

    https://python-poetry.org/docs/dependency-specification/#python-restricted-dependencies,
    https://python-poetry.org/docs/dependency-specification/#using-environment-markers
```

then edit `src-python/pyproject.toml` first to specify specific versions of Python that this project is compatible with, as opposed to all future versions of Python by default. For example, if it looks like this:

```toml
...

[tool.poetry.dependencies]
python = "^3.11"

...
```

you should change it to

```toml
...

[tool.poetry.dependencies]
python = "~3.11"

...
```

Now, you should be able to execute this again successfully:

```bash
$ poetry add pyinstaller --group dev
Using version ^5.13.0 for pyinstaller

Updating dependencies
Resolving dependencies... Downloading https://files.pythonhosted.org/packages/d9/2f/675f01ccfccabf18cfb211feb7280cc13cfc1253eda4a6ffee32b56e1bdb/pyinstaller_hoo
Resolving dependencies... Downloading https://files.pythonhosted.org/packages/55/26/d0ad8b448476d0a1e8d3ea5622dc77b916db84c6aa3cb1e1c0965af948fc/pefile-2023.2.7
Resolving dependencies... (2.7s)

Package operations: 3 installs, 0 updates, 0 removals

  • Installing altgraph (0.17.3)
  • Installing pyinstaller-hooks-contrib (2023.6)
  • Installing pyinstaller (5.13.0)

Writing lock file
```

Now, assuming you don't already have an entry-point for the program, create one at `zamm/main.py`:


```python
"""Entry-point for ZAMM Python functionality."""

def hello_world():
    """Say hello-world."""
    print("Hi there world")

hello_world()
```

As noted in the Tauri docs:

> A binary with the same name and a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance, `"externalBin": ["binaries/my-sidecar"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux.

First find out the target triple:

```bash
$ rustc -Vv | grep host | cut -f2 -d' '
x86_64-unknown-linux-gnu
```

Then create the directory to store the generated binary in:

```bash
$ mkdir src-tauri/binaries
```

Edit `src-tauri/.gitignore` to include this new binaries directory, from:

```
# Generated by Cargo
# will have compiled files and executables
/target/


```

to

```
# Generated by Cargo
# will have compiled files and executables
/target/
/binaries/

```

Edit `src-tauri/.rustfmt.toml` to set a max line width that's the same as `black` in Python:

```toml
# to be compatible with Python black
max_width = 88
```

Now, bundle everything into one single file with the given name in that directory:

```bash
$ cd src-python
$ pyinstaller -F zamm/main.py --distpath ../src-tauri/binaries/ --name zamm-python-x86_64-unknown-linux-gnu
268 INFO: PyInstaller: 5.13.0
269 INFO: Python: 3.11.4
271 INFO: Platform: Linux-5.15.0-78-generic-x86_64-with-glibc2.31
...
28503 INFO: Copying bootloader EXE to /home/amos/Documents/ui/zamm/src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu
28504 INFO: Appending PKG archive to custom ELF section in EXE
28573 INFO: Building EXE from EXE-00.toc completed successfully.
```

We can edit the `src-python/Makefile` to produce this as a target, from this:

```Makefile
...
clean:
# https://stackoverflow.com/a/41386937/257583
	find . -type f -name '*.py[co]' -delete -o -type d -name __pycache__ -delete
```

to this:

```Makefile
...
clean:
# https://stackoverflow.com/a/41386937/257583
	find . -type f -name '*.py[co]' -delete -o -type d -name __pycache__ -delete
	rm -rf build

sidecar:
	pyinstaller -F zamm/main.py --distpath ../src-tauri/binaries/ --name zamm-python-x86_64-unknown-linux-gnu
```

Check that the bundled app runs successfully:

```bash
$ src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu
Hello, World! You have been greeted from Python
$ src-tauri/binaries/zamm-python-x86_64-unknown-linux-gnu Amos
Hello, Amos! You have been greeted from Python
```

Finally, follow the instructions [here](https://tauri.app/v1/guides/building/sidecar/) to invoke that new binary from Tauri. First, edit `src-tauri/tauri.conf.json`. If it currently looks like this:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

then edit it to look like this:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "externalBin": [
        "binaries/zamm-python"
      ],
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

## Invoking the sidecar from Rust

Edit `src-tauri/Cargo.toml` to enable the `process-command-api` feature:

```toml
...

[dependencies]
tauri = { version = "1.4", features = ["shell-open"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

...
```

to

```toml
...

[dependencies]
tauri = { version = "1.4", features = ["shell-open", "process-command-api"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

...
```

Add `futures` to allow us to synchronously get 

```rust
cargo add futures
    Updating crates.io index
      Adding futures v0.3.28 to dependencies.
             Features:
             + alloc
             + async-await
             + executor
             + std
             - bilock
             - cfg-target-has-atomic
             - compat
             - futures-executor
             - io-compat
             - thread-pool
             - unstable
             - write-all-vectored
    Updating crates.io index
```

Edit `src-tauri/src/main.rs`:

```rust
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

and modify the existing function to call this sidecar instead:

```rust
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
#[tauri::command]
fn greet(name: &str) -> String {
    // `new_sidecar()` expects just the filename, NOT the whole path like in JavaScript
    let (mut rx, mut _child) = Command::new_sidecar("zamm-python")
        .expect("failed to create `zamm-python` binary command")
        .args(vec![name])
        .spawn()
        .expect("Failed to spawn sidecar");

    // https://stackoverflow.com/a/52521592
    let result = executor::block_on(tauri::async_runtime::spawn(async move {
        let mut last_line = "No output".to_string();
        // read events such as stdout
        while let Some(event) = rx.recv().await {
            if let CommandEvent::Stdout(line) = event {
                last_line = format!("{} via Rust!", line);
            }
        }
        return last_line;
    }));
    return result.unwrap_or("Failed to get output".to_string());
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

Now if you run `yarn tauri dev`, you should be able to enter in your name and see it say:

> Hello, Amos! You have been greeted from Python via Rust!

## Invoking the sidecar from JS

If instead you'd like to call it directly from the frontend, edit `src/lib/Greet.svelte`. If it currently looks like this:

```svelte
<script lang="ts">
  import { invoke } from "@tauri-apps/api/tauri"

  let name = "";
  let greetMsg = ""

  async function greet(){
    // Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
    greetMsg = await invoke("greet", { name })
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={greet}>
    <input id="greet-input" placeholder="Enter a name..." bind:value={name} />
    <button type="submit">Greet</button>
  </form>
  <p>{greetMsg}</p>
</div>
```

then edit it to instead be:

```svelte
<script lang="ts">
  import { Command } from '@tauri-apps/api/shell'

  let name = "";
  let greetMsg = ""

  async function greet(){
    // alternatively, use `window.__TAURI__.shell.Command`
    // `binaries/my-sidecar` is the EXACT value specified on `tauri.conf.json > tauri > bundle > externalBin`
    const command = Command.sidecar('binaries/zamm-python', [
      name,
    ])
    const result = await command.execute()
    greetMsg = result.stdout + " via JavaScript!"
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={greet}>
    <input id="greet-input" placeholder="Enter a name..." bind:value={name} />
    <button type="submit">Greet</button>
  </form>
  <p>{greetMsg}</p>
</div>
```

For JS specifically, you will also need to edit `src-tauri/tauri.conf.json` to include the binary in the allowlist. In other words:

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

should become

```json
...
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true,
        "sidecar": true,
        "scope": [
          {
            "name": "binaries/zamm-python",
            "sidecar": true,
            "args": true
          }
        ]
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "dev.zamm",
      "externalBin": [
        "binaries/zamm-python"
      ],
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
...
```

Now if you run `yarn tauri dev`, you should be able to enter in your name and see:

> Hello, Amos! You have been greeted from Python via JavaScript!

The final AppImage binary built by `cargo tauri build` will be approximately 12 MB bigger.
