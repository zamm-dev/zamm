# Making Tauri IPC type-safe with Specta

To make sure type declarations are consistent between Tauri and Svelte, we can use Specta to generate type-safe IPC bindings. Follow the instructions [here](https://github.com/oscartbeaumont/tauri-specta).

```bash
$ cargo add specta
$ cargo add tauri-specta --features javascript,typescript
```

Add imports:

```rust
use specta::specta;
use specta::collect_types;
use tauri_specta::ts;
```

then add `#[specta]` to the function definition, so that it goes from:

```rust
#[tauri::command]
fn greet(name: &str) -> String {
    ...
}
```

to

```rust
#[tauri::command]
#[specta]
fn greet(name: &str) -> String {
    ...
}
```

Also, add this line to the Rust entrypoint, from:

```rust
fn main() {
    let possible_db = setup::get_db();
```

to

```rust
fn main() {
    #[cfg(debug_assertions)]
    ts::export(collect_types![greet], "../src-svelte/src/lib/bindings.ts").unwrap();

    let possible_db = setup::get_db();
```

Now try running `yarn tauri dev`. You shold see something generated in `src-svelte/src/lib/bindings.ts`:

```ts
/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

declare global {
    interface Window {
        __TAURI_INVOKE__<T>(cmd: string, args?: Record<string, unknown>): Promise<T>;
    }
}

// Function avoids 'window not defined' in SSR
const invoke = () => window.__TAURI_INVOKE__;

export function greet(name: string) {
    return invoke()<string>("greet", { name })
}



```

Now edit `src-svelte/src/routes/greet/+page.svelte` from

```svelte
<script lang="ts">
  import { invoke } from "@tauri-apps/api/tauri"

  let name = "";
  let greetMsg = ""

  async function greet(){
    // Learn more about Tauri commands at https://tauri.app/v1/guides/features/command
    greetMsg = await invoke("greet", { name })
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={greet}>
  ...
```

to

```svelte
<script lang="ts">
  import { greet } from "$lib/bindings";

  let name = "";
  let greetMsg = "";

  async function trigger_greet() {
    const result = await greet(name);
    greetMsg = result + " via TypeScript!";
  }
</script>

<div>
  <form class="row" on:submit|preventDefault={trigger_greet}>
  ...
```

renaming `greet` to `trigger_greet` to avoid name collision.

If you had set up [a Python sidecar](/zamm/resources/tutorials/setup/tauri/python-sidecar.md) before, now when you go to press the "Greet" button, you should be welcomed with

> Hello, dude! You have been greeted from Python via Rust via TypeScript!

## Compilation warnings

To avoid

```
warning: unused import: `specta::collect_types`
 --> src/main.rs:7:5
  |
7 | use specta::collect_types;
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `tauri_specta::ts`
  --> src/main.rs:10:5
   |
10 | use tauri_specta::ts;
   |     ^^^^^^^^^^^^^^^^
```

surround the imports with the same tag:

```rust
#[cfg(debug_assertions)]
use specta::collect_types;

#[cfg(debug_assertions)]
use tauri_specta::ts;
```

## Frontend tests

If you have previously set up frontend tests [here](/zamm/resources/tutorials/setup/tauri/vitest.md) in addition with [mocked sidecar invocation](/zamm/resources/tutorials/setup/tauri/python-sidecar.md), you may now get an error such as

```
 FAIL  src/routes/greet/Greet.test.ts [ src/routes/greet/Greet.test.ts ]
Error: Failed to resolve import "$lib/bindings" from "src/routes/greet/+page.svelte". Does the file exist?
```

Look at https://github.com/sveltejs/kit/pull/5094. Edit `src-svelte/vitest.config.js` to include the new `resolve` dict:

```ts
import { defineConfig } from "vitest/config";
import { svelte } from "@sveltejs/vite-plugin-svelte";
import * as path from 'path';

export default defineConfig({
  plugins: [svelte({ hot: !process.env.VITEST })],
  resolve: {
		alias: {
			$lib: path.resolve('src/lib')
		}
	},
  test: {
    include: ["src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"],
    globals: true,
    environment: "jsdom",
  },
});
```

Now we have a different error:

```
 DEV  v0.34.1 /root/zamm/src-svelte

 ❯ src/routes/greet/Greet.test.ts (1)
   × invoke simple

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  src/routes/greet/Greet.test.ts > invoke simple
AssertionError: expected "spy" to be called at least once
 ❯ src/routes/greet/Greet.test.ts:45:15
     43|   await act(() => userEvent.click(greet_button));
     44| 
     45|   expect(spy).toHaveBeenCalled();
       |               ^
     46| 
     47|   const message = screen.getByRole("paragraph");

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Unhandled Errors ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Unhandled Rejection ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
TypeError: invoke(...) is not a function
 ❯ Module.greet src/lib/bindings.ts:17:17
     15| 
     16| export function greet(name: string) {
     17|   return invoke()<string>("greet", { name });
       |                 ^
     18| }
     19| 
```

If we look at `src/lib/bindings.ts`:

```ts
/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

declare global {
    interface Window {
        __TAURI_INVOKE__<T>(cmd: string, args?: Record<string, unknown>): Promise<T>;
    }
}

// Function avoids 'window not defined' in SSR
const invoke = () => window.__TAURI_INVOKE__;

export function greet(name: string) {
    return invoke()<string>("greet", { name })
}

```

and try to `console.log(window.__TAURI_INVOKE__)` during the test, we see that it is indeed `undefined`. It is undefined because it is normally injected by Tauri, which is of course not running when we are running pure frontend tests. As such, we should therefore change how we mock things in `src-svelte/src/routes/greet/Greet.test.ts`:

```ts
import { expect, test, vi } from "vitest";
import "@testing-library/jest-dom";

import { act, render, screen } from "@testing-library/svelte";
import userEvent from "@testing-library/user-event";
import Greet from "./+page.svelte";

const tauriInvokeMock = vi.fn(
  async (_: string, args: Record<string, unknown>) =>
    `Hello, ${args.name}! You've been greeted from Python`,
);

vi.stubGlobal("__TAURI_INVOKE__", tauriInvokeMock);

test("invoke simple", async () => {
  const spy = vi.spyOn(window, "__TAURI_INVOKE__");
  expect(spy).not.toHaveBeenCalled();

  render(Greet, {});
  const greet_input = screen.getByRole("textbox");
  await act(() => userEvent.type(greet_input, "Vitest"));
  const greet_button = screen.getByRole("button");
  await act(() => userEvent.click(greet_button));

  expect(spy).toHaveBeenCalled();

  const message = screen.getByRole("paragraph");
  expect(message).toHaveTextContent(
    /^Hello, Vitest! You've been greeted from Python via TypeScript!$/,
  );
});
```

Alternatively, you can mock the exact return value and expect the exact arguments with:

```ts
import { expect, test, vi } from "vitest";
import "@testing-library/jest-dom";

import { act, render, screen } from "@testing-library/svelte";
import userEvent from "@testing-library/user-event";
import Greet from "./+page.svelte";

const tauriInvokeMock = vi.fn();

vi.stubGlobal("__TAURI_INVOKE__", tauriInvokeMock);

test("invoke simple", async () => {
  const spy = vi.spyOn(window, "__TAURI_INVOKE__");
  expect(spy).not.toHaveBeenCalled();
  tauriInvokeMock.mockReturnValueOnce(
    Promise.resolve("Hello, Vitest! You've been greeted from Python"),
  );

  render(Greet, {});
  const greet_input = screen.getByRole("textbox");
  await act(() => userEvent.type(greet_input, "Vitest"));
  const greet_button = screen.getByRole("button");
  await act(() => userEvent.click(greet_button));

  expect(spy).toHaveBeenLastCalledWith("greet", { name: "Vitest" });

  const message = screen.getByRole("paragraph");
  expect(message).toHaveTextContent(
    /^Hello, Vitest! You've been greeted from Python via TypeScript!$/,
  );
});
```
